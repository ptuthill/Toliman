import numpy as np
from lib.conversions import *
from scipy.ndimage import zoom

def FT_model_broadband(pupil, aperture, m2_obsc, chip_dim, wavels, weights, foc_length, pix_size, transform_size, q1, q2, polar=True):
    """
    Models the PSF generated by a point source of light generated by the input phase pupil across a spectrum
    Works through repetative calls of FT_model
    
    Inputs:
        pupil: Phase pupil complex array 
        aperture: Telescope aperture diameter (m)
        m2_obsc: Aperture of central obscuration from the secondary mirror (m)
        chip dim: Units of pixels (int), this should be an even int to prevent rounding error
        wavels: Array of wavelengths (m)
        weights: Array of relative weights for each wavelength
        foc_lenght: Effective focal lenght of telescope (m)
        pix_size: Detector pitch, size of pixel unit cell (m)
        transform_size: Size of the desired array to fourier transform(power of 2)
        q1, q2: coordinate specifying the positional offset from the normal of th telescope of the observed star
            if polar: polar coordinates - q1:r (arcseconds), q2:phi (radians)
            else: cartesian coordinates - q1:x (pixels), q2:y (pixels)
        
    Returns:
        Numpy array representing the normalised PSF as it appears on the detector
        
    """  
    im_out = np.zeros((chip_dim,chip_dim))
    for wavel, weight in zip(wavels, weights):
        im_out += weight * FT_model(pupil, aperture, m2_obsc, chip_dim, wavel, foc_length, pix_size, transform_size, q1, q2, polar=True)
    
    # Normalise
    PSF = im_out/np.sum(im_out)
    
    return PSF

def FT_model(pupil, aperture, m2_obsc, chip_dim, wl, foc_length, pix_size, transform_size, q1, q2, polar=True):
    """
    Models the PSF generated by a point source of light generated by the input phase pupil
    
    Inputs:
        pupil: Phase pupil complex array 
        aperture: Telescope aperture diameter (m)
        m2_obsc: Aperture of central obscuration from the secondary mirror (m)
        chip dim: Units of pixels (int), this should be an even int to prevent rounding error
        wl: Wavelength (m)
        foc_lenght: Effective focal lenght of telescope (m)
        pix_size: Detector pitch, size of pixel unit cell (m)
        transform_size: Size of the desired array to fourier transform(power of 2)
        q1, q2: coordinate specifying the positional offset from the normal of th telescope of the observed star
            if polar: polar coordinates - q1:r (arcseconds), q2:phi (radians)
            else: cartesian coordinates - q1:x (pixels), q2:y (pixels)
        
    Returns:
        Numpy array representing the normalised PSF as it appears on the detector
        
    """        
    # Take the Real part of the pupil to allow scaling with scipy.ndimage.zoom()
    Re = pupil.real
    pupil_size = pupil.shape[0]
    
    # Caclaute how big the pupil array needs to be to get our desired Fourier Transformed array size
    plate_scale = pix_size/foc_length    # Radians per pixel
    spatial_freq = wl/aperture
    scale_factor = spatial_freq/plate_scale
    size_out = int(transform_size/scale_factor)
    
    # Scale the real component of the pupil to this size
    size_in = pupil_size
    ratio = size_out/size_in    
    Re_scaled = zoom(Re, ratio)
    
    # Zero the components outside of the aperture to zero
    c = size_out//2
    s = np.linspace(-c, c, num=size_out, endpoint=False)
    X,Y = np.meshgrid(s, s)
    R = np.hypot(X,Y)
    Re_scaled[R > c-1] = 0 
    # Note the -1 here is to account for rounding errors intoruced by interger divisions
    
    # Create the new pupil from a real and imaginary component
    pupil_scaled = Re_scaled + np.zeros([size_out, size_out]) * 1j
    
    # Convert the coordinates to polar if cartesian or convert r to radians for phase gradient functions
    if not polar:
        r = np.hypot(q1, q2) * plate_scale # radians
        phi = np.arctan2(q2, q1) # radians
    else:
        r = arcsec_to_rad(q1)
        phi = q2
    
    
    # Apply the phase gradient to the pupil
    pupil_new = apply_phase_gradient(pupil_scaled, aperture, wl, r, phi)
    
    # Apply the seconday mirror central obscuration
    radius = aperture/2
    radii_range = np.linspace(-radius, radius, num=size_out, endpoint=False)
    X,Y = np.meshgrid(radii_range, radii_range)
    R = np.hypot(X,Y)
    
    mag_array = np.ones(Re_scaled.shape)
    mag_array[R > radius] = 0 
    mag_array[R < m2_obsc/2] = 0
    phase_array = np.angle(pupil_new)
    
    pupil_out = mag_array * np.exp(1j*phase_array)
    
    # Perform the FT
    array_out = np.zeros((transform_size,transform_size),dtype=complex)
    array_out[0:size_out, 0:size_out] = pupil_out
    im = np.fft.fftshift(np.abs(np.fft.fft2(array_out))**2)
        
    # Take the part that falls on the chip
    start = (transform_size-chip_dim)//2
    end = transform_size - (transform_size-chip_dim)//2
    im_out = im[start:end, start:end]
    
    # Normalise
    PSF = im_out/np.sum(im_out)
    
    return PSF

def apply_phase_gradient(pupil, aperture, wavelength, r, phi):
    """
    Applies the change in phase across the pupil induced by an off centre star to the input binarised phase pupil
    
    Inputs:
        pupil: complex array representing the phase pupil
        aperture: Aperture of the telescope (m)
        wavelength: Wavelength to be modelled (m)
        r: radial offset from normal of telescope aperture in polar coordaintes (radians)
        phi: angular offset from the positive x plane (radians)
        
    Returns:
        Complex numpy array with the phase gradient for off-axis stars applied
    """
    if r == 0:
        return pupil
    
    phase = calculate_phase_gradient(pupil, aperture, wavelength, r, phi, shift=False)
    anti_phase = calculate_phase_gradient(pupil, aperture, wavelength, r, phi, shift=True)
    
    mask = np.angle(pupil) > 0
    inv_mask = -(mask - 1)
    
    selection1 = np.multiply(phase, inv_mask)
    selection2 = np.multiply(anti_phase, mask)
    aperture_phase = selection1 + selection2
    
    pupil_phase = np.exp(1j*aperture_phase)
    
    return pupil_phase

def calculate_phase_gradient(pupil, aperture, wavelength, r, phi, shift=False):
    """
    Calculates the change in phase across the pupil induced by an off centre star
    
    Inputs:
        pupil: complex array representing the phase pupil
        aperture: Aperture of the telescope (m)
        wavelength: Wavelength to be modelled (m)
        r: radial offset from normal of telescope aperture in polar coordaintes (radians)
        phi: angular offset from the positive x plane (radians)
        
    Returns: numpy array of the phase change of the incident light across the pupil apertuere 
    """
    # Create an xy coordinate grid
    gridsize = pupil.shape[0]        
    Xs = np.linspace(-gridsize//2,(gridsize//2), num=gridsize, endpoint=False)
    X, Y = np.meshgrid(Xs, Xs)
    
    # Convert to polar coords
    R = np.hypot(X, Y)
    theta_array = np.arctan2(X, Y) 
    
    # Rotate the array by the phi offset
    theta_array_shifted = theta_array - phi 
    
    # Convert back to cartesian coordiantes for typical use
    y_new = R * np.sin(theta_array_shifted)

    # Calculate the scaling values from the wavelength and offset
    OPD = aperture*np.tan(r)
    cycles = OPD/wavelength
    period = gridsize/cycles
    
    # Phase shift for reccessed regions of pupil
    if shift:
        phase_shift = period/2
    else:
        # Note this may be redundant - it was introduced to curb introduced distortions which may have been from an earier bug
        phase_shift = period
        
    # Apply phase shift to array
    y_new += phase_shift
    
    # Scale phase change based on calculated scaling values
    phase_array = y_new * 2*np.pi/period
    
    return phase_array