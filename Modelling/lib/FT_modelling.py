import numpy as np
from lib.conversions import *
from scipy.ndimage import zoom

def FT_model_broadband(pupil, aperture, m2_obsc, chip_dim, wavels, weights, foc_length, pix_size, transform_size, q1, q2, polar=True, leakages=[]):
    """
    Models the PSF generated by a point source of light generated by the input phase pupil across a spectrum
    Works through repetative calls of FT_model
    
    Inputs:
        pupil: Phase pupil complex array 
        aperture: Telescope aperture diameter (m)
        m2_obsc: Aperture of central obscuration from the secondary mirror (m)
        chip dim: Units of pixels (int), this should be an even int to prevent rounding error
        wavels: Array of wavelengths (m)
        weights: Array of relative weights for each wavelength
        foc_lenght: Effective focal lenght of telescope (m)
        pix_size: Detector pitch, size of pixel unit cell (m)
        transform_size: Size of the desired array to fourier transform(power of 2)
        q1, q2: coordinate specifying the positional offset from the normal of th telescope of the observed star
            if polar: polar coordinates - q1:r (arcseconds), q2:phi (radians)
            else: cartesian coordinates - q1:x (pixels), q2:y (pixels)
        leakages: an array of leakage per wavelength given as a float, ie 4% == 0.04 (%)
        
    Returns:
        Numpy array representing the normalised PSF as it appears on the detector
        
    """  
    im_out = np.zeros((chip_dim,chip_dim))
    if len(leakages) == 0:
        for wavel, weight in zip(wavels, weights):
            im_out += weight * FT_model(pupil, aperture, m2_obsc, chip_dim, wavel, foc_length, pix_size, transform_size, q1, q2, polar=polar, leakage=0.0)
    else:
        for wavel, weight, leakage in zip(wavels, weights, leakages):
            im_out += weight * FT_model(pupil, aperture, m2_obsc, chip_dim, wavel, foc_length, pix_size, transform_size, q1, q2, polar=polar, leakage=leakage)
    
    # Normalise
    PSF = im_out/np.sum(im_out)
    
    return PSF

def FT_model_binary(pupil, aperture, m2_obsc, chip_dim, wavels_2D, weights_2D, total_flux_2D, foc_length, pix_size, transform_size, q1_2D, q2_2D, polar=True, leakages_2D=[[],[]]):
    """
    Models two binary stars on a broadband spectrum using Fourier transforms
    Models the PSF generated by a point source of light generated by the input phase pupil across a spectrum
    Works through repetative calls of FT_model
    
    Inputs:
        pupil: Phase pupil complex array 
        aperture: Telescope aperture diameter (m)
        m2_obsc: Aperture of central obscuration from the secondary mirror (m)
        chip dim: Units of pixels (int), this should be an even int to prevent rounding error
        wavels_2D: 2D Array of wavelengths, one for each star (m)
        weights_2D: 2D Array of relative weights for each wavelength, one for each star
        total_flux_2D: total flux of each star, used to scale the final PSFs
        foc_lenght: Effective focal lenght of telescope (m)
        pix_size: Detector pitch, size of pixel unit cell (m)
        transform_size: Size of the desired array to fourier transform(power of 2)
        q1_2D, q2_2D: 2 1D arrays of coordinates specifying the positional offset from the normal of th3 telescope of the observed star
            if polar: polar coordinates - q1:r (arcseconds), q2:phi (radians)
            else: cartesian coordinates - q1:x (pixels), q2:y (pixels)
        leakages_2D: an 2D array of leakage per wavelength given as a float, ie 4% == 0.04 (%), one for each star
        
    Sample inputs:
        wavels_2D = [[595e-9, 600e-9, 605e-9], [595e-9, 600e-9, 605e-9]]
        weights_2D = [[0.8, 0.9, 0.95], [0.6, 0.7, 0.8]]
        total_fluxes_2D = [1e10, 1e9]
        q1_2D = [0, 5]
        q2_2D = [0, 6]
            => translates to coordinates of (0,0) and (5,6)
        leakages_2D = [[0.01, 0.02, 0.02], [0.02, 0.03, 0.04]]
        
    Returns:
        Numpy array representing the normalised PSF as it appears on the detector
        
    """  
    
    PSF_out = np.zeros([chip_dim, chip_dim])
    for wavels, weights, total_flux, q1, q2, leakage in zip(wavels_2D, weights_2D, total_flux_2D, q1_2D, q2_2D, leakages_2D):
        PSF = FT_model_broadband(pupil, aperture, m2_obsc, chip_dim, wavels, weights, foc_length, pix_size, transform_size, q1, q2, polar=polar, leakages=leakage)
        
        # Add to output array
        PSF_out += PSF * total_flux
        
    # Normalise output array
    PSF_out = PSF_out/np.sum(PSF_out)
    
    return PSF_out

def FT_model(pupil, aperture, m2_obsc, chip_dim, wl, foc_length, pix_size, transform_size, q1, q2, polar=True, leakage=0.0):
    """
    Models the PSF generated by a point source of light generated by the input phase pupil
    
    Inputs:
        pupil: Phase pupil complex array 
        aperture: Telescope aperture diameter (m)
        m2_obsc: Aperture of central obscuration from the secondary mirror (m)
        chip dim: Units of pixels (int), this should be an even int to prevent rounding error
        wl: Wavelength (m)
        foc_lenght: Effective focal lenght of telescope (m)
        pix_size: Detector pitch, size of pixel unit cell (m)
        transform_size: Size of the desired array to fourier transform(power of 2)
        q1, q2: coordinate specifying the positional offset from the normal of th telescope of the observed star
            if polar: polar coordinates - q1:r (arcseconds), q2:phi (radians)
            else: cartesian coordinates - q1:x (pixels), q2:y (pixels)
        leakage: Leakage term given as a float, ie 4% == 0.04 (%)
        
    Returns:
        Numpy array representing the normalised PSF as it appears on the detector        
    """ 
    # Caclaute how big the pupil array needs to be to get our desired Fourier Transformed array size
    plate_scale = pix_size/foc_length    # Radians per pixel
    spatial_freq = wl/aperture
    scale_factor = spatial_freq/plate_scale
    size_out = int(transform_size/scale_factor)
    
    # Scale pupil 
    pupil_scaled = scale_pupil(pupil, size_out)
    
    # Convert the coordinates to polar if cartesian or convert r to radians for phase gradient functions
    if not polar:
        r = np.hypot(q1, q2) * plate_scale # radians
        phi = np.arctan2(q2, q1) # radians
    else:
        r = arcsec_to_rad(q1)
        phi = q2
     
    # Apply the phase gradient to the pupil
    pupil_new = apply_phase_gradient(pupil_scaled, aperture, wl, r, phi)
    
    # Apply the seconday mirror central obscuration and zero the power out of the apertrure
    radius = aperture/2
    radii_range = np.linspace(-radius, radius, num=size_out, endpoint=False)
    X,Y = np.meshgrid(radii_range, radii_range)
    R = np.hypot(X,Y)
    
    mag_array = np.ones(pupil_scaled.real.shape)
    mag_array[R > radius] = 0 
    mag_array[R < m2_obsc/2] = 0
    phase_array = np.angle(pupil_new)
    pupil_out = mag_array * np.exp(1j*phase_array)
    
    # Perform the FT
    array_out = np.zeros((transform_size,transform_size),dtype=complex)
    array_out[0:size_out, 0:size_out] = pupil_out
    im = np.fft.fftshift(np.abs(np.fft.fft2(array_out))**2)
    
    # Take the part that falls on the chip
    start = (transform_size-chip_dim)//2
    end = transform_size - (transform_size-chip_dim)//2
    im_out = im[start:end, start:end]
    
    # Generate an empty pupil
    empty_pupil = np.zeros((size_out, size_out), dtype=complex)
    C = np.linspace(-size_out//2, size_out//2, num=size_out, endpoint=False)
    X_empty, Y_empty = np.meshgrid(C, C)
    R_empty = np.hypot(X_empty, Y_empty)
    empty_pupil[R_empty < size_out//2] = np.complex(1, 0)
    
    # Apply the phase gradient across the empty pupil
    empty_pupil = apply_phase_empty(empty_pupil, aperture, wl, r, phi)
    
    # Apply the seconday mirror central obscuration and zero the power out of the apertrure
    mag_array = np.ones(empty_pupil.real.shape)
    mag_array[R > radius] = 0 
    mag_array[R < m2_obsc/2] = 0
    phase_array = np.angle(empty_pupil)
    empty_pupil_out = mag_array * np.exp(1j*phase_array)
    
    # Perform FT on empty pupil
    array_out_empty = np.zeros((transform_size,transform_size),dtype=complex)
    array_out_empty[0:size_out, 0:size_out] = empty_pupil_out
    im_empty = np.fft.fftshift(np.abs(np.fft.fft2(array_out_empty))**2)

    # Take the part that falls on the chip
    start = (transform_size-chip_dim)//2
    end = transform_size - (transform_size-chip_dim)//2
    im_out_empty = im_empty[start:end, start:end]
    
    # Normalise and sum 
    PSF = (1 - leakage) * im_out/np.sum(im_out)
    PSF_empty = leakage * im_out_empty/np.sum(im_out_empty)
    PSF_out = PSF + PSF_empty
    
    return PSF_out

def scale_pupil(pupil, output_size):
    """
    Takes in the complex pupil array and returns a scaled version
    
    NOTE: This appears to remove the grating from the pupil. 
    A More complex version is needed to fix this
    
    Inputs:
        pupil: 2D Complex np array of the phase pupil
        output_size: Size of the pupil array to be returned
        
    Returns:
        pupil_scaled: 2D Complex np array of the pupil in the dimension of output_sizeXoutput_size
    """
    # Scale the real component of the pupil to this size
    size_in = pupil.shape[0]
    ratio = output_size/size_in    
    Re_scaled = zoom(pupil.real, ratio)
    
    # Zero the components outside of the aperture to zero
    c = output_size//2
    s = np.linspace(-c, c, num=output_size, endpoint=False)
    X,Y = np.meshgrid(s, s)
    R = np.hypot(X,Y)
    Re_scaled[R > c-1] = 0 
    # Note the -1 here is to account for rounding errors intoruced by interger divisions
    
    # Create the new pupil from a real and imaginary component
    pupil_scaled = Re_scaled + np.zeros([output_size, output_size]) * 1j
    
    return pupil_scaled
    
def apply_phase_gradient(pupil, aperture, wavelength, r, phi):
    """
    Applies the change in phase across the pupil induced by an off centre star to the input binarised phase pupil
    
    Inputs:
        pupil: complex array representing the phase pupil
        aperture: Aperture of the telescope (m)
        wavelength: Wavelength to be modelled (m)
        r: radial offset from normal of telescope aperture in polar coordaintes (radians)
        phi: angular offset from the positive x plane (radians)
        
    Returns:
        Complex numpy array with the phase gradient for off-axis stars applied
    """
    if r == 0:
        return pupil
    
    phase = calculate_phase_gradient(pupil, aperture, wavelength, r, phi, shift=False)
    anti_phase = calculate_phase_gradient(pupil, aperture, wavelength, r, phi, shift=True)
    
    mask = np.angle(pupil) > 0
    inv_mask = -(mask - 1)
    
    selection1 = np.multiply(phase, inv_mask)
    selection2 = np.multiply(anti_phase, mask)
    aperture_phase = selection1 + selection2
    
    pupil_phase = np.exp(1j*aperture_phase)
    
    return pupil_phase

def calculate_phase_gradient(pupil, aperture, wavelength, r, phi, shift=False):
    """
    Calculates the change in phase across the pupil induced by an off centre star
    
    Inputs:
        pupil: complex array representing the phase pupil
        aperture: Aperture of the telescope (m)
        wavelength: Wavelength to be modelled (m)
        r: radial offset from normal of telescope aperture in polar coordaintes (radians)
        phi: angular offset from the positive x plane (radians)
        
    Returns: numpy array of the phase change of the incident light across the pupil apertuere 
    """
    # Create an xy coordinate grid
    gridsize = pupil.shape[0]        
    Xs = np.linspace(-gridsize//2,(gridsize//2), num=gridsize, endpoint=False)
    X, Y = np.meshgrid(Xs, Xs)
    
    # Convert to polar coords
    R = np.hypot(X, Y)
    theta_array = np.arctan2(X, Y) 
    
    # Rotate the array by the phi offset
    theta_array_shifted = theta_array - phi 
    
    # Convert back to cartesian coordiantes for typical use
    y_new = R * np.sin(theta_array_shifted)

    # Calculate the scaling values from the wavelength and offset
    OPD = aperture*np.tan(r)
    cycles = OPD/wavelength
    period = gridsize/cycles
    
    # Phase shift for reccessed regions of pupil
    if shift:
        phase_shift = period/2
    else:
        # Note this may be redundant - it was introduced to curb introduced distortions which may have been from an earier bug
        phase_shift = period
        
    # Apply phase shift to array
    y_new += phase_shift
    
    # Scale phase change based on calculated scaling values
    phase_array = y_new * 2*np.pi/period
    
    return phase_array